"""
nequippotential.py: Implements the NequIP potential function.

This is part of the OpenMM molecular simulation toolkit originating from
Simbios, the NIH National Center for Physics-Based Simulation of
Biological Structures at Stanford, funded under the NIH Roadmap for
Medical Research, grant U54 GM072970. See https://simtk.org.

Portions copyright (c) 2024-2026 Stanford University and the Authors.
Authors: Peter Eastman
Contributors: Stephen Farr, Joao Morado

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS, CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.
"""

from typing import Iterable, List, Optional
import openmm
from openmm import unit
from openmmml.mlpotential import MLPotentialImpl, MLPotentialImplFactory
from functools import partial


class NequIPPotentialImplFactory(MLPotentialImplFactory):
    """This is the factory that creates NequipPotentialImpl objects."""

    def createImpl(
        self,
        name: str,
        modelPath: str,
        lengthScale: float,
        energyScale: float,
    ) -> MLPotentialImpl:
        return NequIPPotentialImpl(name, modelPath, lengthScale, energyScale)


class NequIPPotentialImpl(MLPotentialImpl):
    """
    This is the MLPotentialImpl implementing support for E(3)-equivariant
    interatomic potentials generated by NequIP or Allegro.

    The potential must be constructed using the NequIP/Allegro code to build
    a PyTorch model, which can then be integrated into OpenMM using a PythonForce.
    Note that you must provide a model, as no general purpose model is available.

    To use a model in OpenMM-ML, you must provide the path to the model checkpoint file,
    and the conversion factors between the model length and energy units and OpenMM
    units (nm and kJ/mol, respectively). For example:

    >>> potential = MLPotential('nequip',
                                modelPath='example_model.ckpt',
                                lengthScale=0.1, # Angstrom to nm
                                energyScale=4.184 # kcal/mol to kJ/mol
                                )

    During system creation, if the model was trained with custom atom types,
    you can specify this by passing to the ``atomTypes`` parameter a list of
    of integers corresponding to the nequip atom type for each particle that
    will be modeled using this potential. This argument should, therefore,
    have the same length as the number of ML atoms in the system.  Note that
    by default the model uses the atomic number to map the atom type. This
    will work if you trained your model using the standard
    ``chemical_symbols`` option.

    Additionally, you can specify the precision of
    the model using the ``precision`` keyword argument. Supported options are
    'single' and 'double'. For example:

    >>> system = potential.createSystem(topology, precision='single')

    By default, the implementation uses the precision of the loaded model.
    Note that models deployed before NequIP v0.6.0 don't contain information
    about their precision, so ``precision='double'`` should only be used if
    the model was explicitly trained with ``default_dtype=float64``, as by
    default the model is trained with ``default_dtype=float32``.
    """
    def __init__(
        self,
        name: str,
        modelPath: str,
        lengthScale: float,
        energyScale: float,
    ) -> None:
        """
        Initialize the NequIPPotentialImpl.

        Parameters
        ----------
        name : str
            The name specified by the MLPotential constructor, viz. 'nequip'.
        modelPath : str, optional
            The path to the model checkpoint file.
        lengthScale : float
            The length conversion factor from the model units to nanometers.
        energyScale : float
            The energy conversion factor from the model units to kJ/mol.
        """
        self.name = name
        self.modelPath = modelPath
        self.lengthScale = lengthScale
        self.energyScale = energyScale

    def addForces(
        self,
        topology: openmm.app.Topology,
        system: openmm.System,
        atoms: Optional[Iterable[int]],
        forceGroup: int,
        precision: Optional[str] = None,
        atomTypes: Optional[List[int]] = None,
        **args,
    ):
        """
        Add the NequIPForce to the OpenMM System.

        Parameters
        ----------
        topology : openmm.app.Topology
            The topology of the system.
        system : openmm.System
            The system to which the force will be added.
        atoms : iterable of int
            The indices of the atoms to include in the model. If ``None``, all atoms are included.
        forceGroup : int
            The force group to which the force should be assigned.
        precision : str, optional
            The precision of the model. Supported options are 'single' and 'double'.
            If ``None``, the default precision of the model is used. This is the
            recommended option. Models deployed before NequIP v0.6.0 don't contain
            information about their precision, so ``precision='double'`` should only be
            used if the model was explicitly trained with ``default_dtype=float64``, 
            as by default the model is trained with ``default_dtype=float32``.
        atomTypes : List[int], optional
            A list of integers corresponding to the nequip atom type for each ML atom in the system.
            This is only required if the model was trained with custom atom types. If ``None``,
            the atomic number is used to determine the atom type. This list should have the same
            length as the number of ML atoms in the system.
        """
        import torch
        try:
            from nequip.nn import graph_model
            from nequip.utils.global_state import set_global_state
            from nequip.model.saved_models.load_utils import load_saved_model
            set_global_state()
        except ImportError as e:
            raise ImportError(f"Failed to import NequIP with error: {e}. Install NequIP with 'pip install nequip'.")

        # Load the model.
        model = load_saved_model(self.modelPath)
        device = self._getTorchDevice(args)
        model.to(device)

        includedAtoms = list(topology.atoms())
        if atoms is not None:
            includedAtoms = [includedAtoms[i] for i in atoms]

        # Try to infer the model dtype from the metadata. If not present, default to float32.
        modelDefaultDtype = {"float32": torch.float32, "float64": torch.float64}[
            model.metadata.get("model_dtype", "float32")
        ]
        # Set the precision that the model will be used with.
        if precision is None:
            dtype = modelDefaultDtype
        elif precision == "single":
            dtype = torch.float32
        elif precision == "double":
            dtype = torch.float64
        else:
            raise ValueError(f"Unsupported precision {precision} for the model. Supported values are 'single' and 'double'.")

        if dtype != modelDefaultDtype:
            print(
                f"Model dtype in metadata is {modelDefaultDtype} and requested dtype is {dtype}. "
                "The model will be converted to the requested dtype. Make sure this is the precision the model was trained with."
            )
            model.to(dtype)

        # Get the atom types
        if atomTypes is None:
            typeNames = model.metadata[graph_model.TYPE_NAMES_KEY].split()
            typeNameToTypeIndex = {typeNames: i for i, typeNames in enumerate(typeNames)}
            atomTypes = [typeNameToTypeIndex[atom.element.symbol] for atom in includedAtoms]
        else:
            if len(atomTypes) != len(includedAtoms):
                raise ValueError("The length of atomTypes must be equal to the number of ML atoms in the system.")
        if atoms is None:
            indices = None
        else:
            indices = torch.tensor(sorted(atoms), dtype=torch.int64, requires_grad=False, device=device)
        atomTypes = torch.tensor(atomTypes, dtype=torch.long, requires_grad=False, device=device)
        periodic = (topology.getPeriodicBoxVectors() is not None) or system.usesPeriodicBoundaryConditions()
        pbc = torch.tensor([periodic, periodic, periodic], dtype=torch.bool, requires_grad=False, device=device)
        cutoff = float(model.metadata[graph_model.R_MAX_KEY])

        # Create the PythonForce and add it to the System.

        compute = partial(_computeNequIP,
                          model=model,
                          atomTypes=atomTypes,
                          cutoff=cutoff,
                          lengthScale=self.lengthScale,
                          energyScale=self.energyScale,
                          indices=indices,
                          periodic=periodic,
                          pbc=pbc)
        force = openmm.PythonForce(compute)
        force.setForceGroup(forceGroup)
        force.setUsesPeriodicBoundaryConditions(periodic)
        system.addForce(force)

def _computeNequIP(state, model, atomTypes, cutoff, lengthScale, energyScale, indices, periodic, pbc):
    import torch
    import numpy as np
    from nequip.data._nl import compute_neighborlist_
    positions = state.getPositions(asNumpy=True).value_in_unit(unit.nanometer)/lengthScale
    numAtoms = positions.shape[0]
    positions = torch.tensor(positions, dtype=torch.float64, device=atomTypes.device)
    if indices is not None:
        positions = positions[indices]
    inputDict = {
        "pos": positions,
        "atom_types": atomTypes,
        "pbc": pbc,
    }
    if periodic:
        inputDict['cell'] = torch.tensor(state.getPeriodicBoxVectors(asNumpy=True).value_in_unit(unit.nanometer)/lengthScale, dtype=torch.float64, device=atomTypes.device)
    compute_neighborlist_(inputDict, cutoff)
    out = model(inputDict)
    energy = out["total_energy"] * energyScale
    forces = out["forces"].detach().cpu().numpy()
    if indices is not None:
        f = np.zeros((numAtoms, 3), dtype=np.float64)
        f[indices] = forces
        forces = f
    return energy, forces*energyScale/lengthScale
